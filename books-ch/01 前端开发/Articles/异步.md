已知，JavaScript 是单线程的，天生异步，适合 IO 密集型，不适合 CPU 密集型，但是，为什么是异步的喃，异步由何而来的喃，我们将在这里逐渐讨论实现。

### 一、进程与线程

#### 1\. 浏览器是多进程的

它主要包括以下进程：

- Browser 进程：浏览器的主进程，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等。
- GPU 进程：用于 3D 绘制等，最多一个。
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。
- 浏览器渲染进程（浏览器内核）：内部是多线程的，每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。

#### 2\. 渲染进程（浏览器内核）

浏览器的渲染进程是多线程的，页面的渲染，JavaScript 的执行，事件的循环，都在这个进程内进行：

- GUI 渲染线程：负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。
- JavaScript 引擎线程：也称为 JavaScript 内核，负责处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码等。（例如 V8 引擎）
- 事件触发线程：用来控制浏览器事件循环，注意这不归 JavaScript 引擎线程管，当事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。
- 定时触发器线程：传说中的 `setInterval` 与 `setTimeout` 所在线程，注意，W3C 在 HTML 标准中规定，规定要求 `setTimeout` 中低于 4ms 的时间间隔算为 4ms 。
- 异步 http 请求线程：在 `XMLHttpRequest` 连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

注意，**GUI 渲染线程与 JavaScript 引擎线程是互斥的**，当 JavaScript 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中**等到 JavaScript 引擎空闲时**立即被执行。所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

### 二、单线程的 JavaScript

所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。

**问题：首先为什么要引入单线程喃？**

我们知道：

- 浏览器需要渲染 DOM
- JavaScript 可以修改 DOM 结构
- JavaScript 执行时，浏览器 DOM 渲染停止

如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。

你可能会说，[web worker](http://www.ruanyifeng.com/blog/2018/07/web-worker.html) 就支持多线程，但是 web worker 不能访问 window 对象，document 对象等。

**原因：避免 DOM 渲染的冲突**

当然，我们可以为浏览器引入**锁** 的机制来解决这些冲突，但其大大提高了复杂性，所以 JavaScript从诞生开始就选择了单线程执行。

引入单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这同时又导致了一个问题：如果前一个任务耗时很长，后一个任务就不得不一直等着。

// 实例1
let i, sum \= 0
for(i \= 0; i < 1000000000; i ++) {
    sum += i
}
console.log(sum)

在实例1中，`sum` 并不能立刻打印出来，必须在 for 循环执行完成之后才能执行 `console.log(sum)` 。

// 实例2
console.log(1)
alert('hello')
console.log(2)

在实例2中，浏览器先打印 `1` ，然后弹出弹框，点击确定后才执行 `console.log(2)` 。

**总结：**

- 优点：实现比较简单，执行环境相对单纯
- 缺点：只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 Javascript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。

为了解决这个问题，JavaScript 语言将任务的执行模式分为两种：同步和异步

### 三、同步与异步

#### 1\. 同步

func(args...)

如果在函数 `func` 返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。

let a \= 1
Math.floor(a)
console.log(a) // 1

#### 2\. 异步

如果在函数 `func` 返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。

fs.readFile('foo.txt', 'utf8', function(err, data) {
    console.log(data);
});

**总结：**

JavaScript 采用异步编程原因有两点，

- 一是 JavaScript 是单线程；
- 二是为了提高 CPU 的利用率。

### 四、异步过程

fs.readFile('data.json', 'utf8', function(err, data) {
    console.log(data)
})

在执行这段代码时，`fs.readFile` 函数返回时，并不会立刻打印 `data` ，只有 `data.json` 读取完成时才打印。也就是异步函数 `fs.readFile` 执行很快，但后面还有工作线程执行异步任务、通知主线程、主线程回调等操作，这个过程就叫做异步过程。

> 主线程发起一个异步操作，相应的工作线程接受请求并告知主线程已收到（异步函数返回）；主线程继续执行后面的任务，同时工作线程执行异步任务；工作线程完成任务后，通知主线程；主线程收到通知后，执行一定的动作（调用回调函数）。

工作线程在异步操作完成后通知主线程，那么这个通知机制又是如何显现喃？答案就是就是消息队列与事件循环。

### 五、消息队列与事件循环

> 工作线程将消息放在消息队列，主线程通过事件循环过程去取消息。

- 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。
- 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。

#### 1\. 事件循环（eventloop）

主线程不断的从消息队列中取消息，执行消息，这个过程称为事件循环，这种机制叫事件循环机制，取一次消息并执行的过程叫一次循环。

大致实现过程如下：

while(true) {
    var message \= queue.get()
    execute(message)
}

例如：

$.ajax({
    url: 'xxxx',
    success: function(result) {
        console.log(1)
    }
})
setTimeout(function() {
    console.log(2)
}, 100)
setTimeout(function() {
    console.log(3)
})
console.log(4)
// output：4321 或 4312

其中，主线程：

// 主线程
console.log(4)

异步队列：

// 异步队列
function () {
    console.log(3)
}
function () { // 100ms后
    console.log(2)
}
function() { // ajax加载完成之后
    console.log(1)
}

**事件循环是JavaScript实现异步的具体解决方案，其中同步代码，直接执行；异步函数先放在异步队列中，待同步函数执行完毕后，轮询执行 异步队列 的回调函数。**

#### 2\. 消息队列

其中，消息就是注册异步任务时添加的回调函数。

$.ajax('XXX', function(res) {
    console.log(res)
})
...

主线程在发起 AJAX 请求后，会继续执行其他代码，AJAX 线程负责请求 `XXX`，拿到请求后，会封装成 JavaScript 对象，然后构造一条消息：

// 消息队列里的消息
var message \= function () {
    callback(response)
}

其中 `callback` 是 AJAX 网络请求成功响应时的回调函数。

主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是 `message` 函数)，并执行它。到此为止，就完成了工作线程对主线程的 `通知` ，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX 线程在收到 HTTP 响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。

[![](https://camo.githubusercontent.com/aaf54264f9f95264d7b202ad33b9b06224f982572d4a34367ac4712ecf604ad0/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139333333392e706e67)](https://camo.githubusercontent.com/aaf54264f9f95264d7b202ad33b9b06224f982572d4a34367ac4712ecf604ad0/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139333333392e706e67)

异步过程中的回调函数，一定不在当前这一轮事件循环中执行。

### 六、异步与事件

消息队列中的每条消息实际上都对应着一个事件。

其中一个重要的异步过程就是： **DOM事件**

var button \= document.getElementById('button')
button.addEventLister('click', function(e) {
    console.log('事件')
})

从异步的角度看，`addEventLister` 函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放在消息队列中，等待主线程执行。

事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。

另外，所有的异步过程也都可以用事件来描述。例如：

setTimeout(func, 1000)
// 可以看成：
timer.addEventLister('timeout', 1000, func)

其中关于事件的详细描述，可以看这篇文章： [事件绑定、事件监听、事件委托](http://blog.xieliqun.com/2016/08/12/event-delegate/)，这里不再深入介绍。

### 七、生产者与消费者

生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加数据，消费者从存储空间中取走数据，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。

[![](https://camo.githubusercontent.com/55112a568c999b757ba149f81ed7ce7d0f5ad623eaeea70f273d93c0aac801e5/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139323732312e676966)](https://camo.githubusercontent.com/55112a568c999b757ba149f81ed7ce7d0f5ad623eaeea70f273d93c0aac801e5/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139323732312e676966)

从生产者与消费者的角度看，异步过程是这样的：

> 工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。

那么异步的实现方式有哪些喃？

- ES6之前：callback、eventloop、Promise
- ES6：Generator
- ES7:Async/Await



# step1：callback

```
asyncFunction(function(value) {
    // todo
})
```

这种回调函数，大家是最熟悉的。一般是需要在某个耗时操作之后执行某个回调函数。

例如：

```
setTimeout(function() {
    console.log('Time out')
}, 1000)
```

其中，我们称`setTimeout`为发起函数，`fn`为回调函数。都是在主线程上调用的，其中发起函数用来发动异步过程，回调函数用来处理结果。在执行`setTimeout`1s后，执行function函数。

下面，我们再看一种情况。

```javascript
$.ajax({
    url:'XXX1',
    success: function(res) {
        $.ajax({
            url:'XXX2',
            success: function(res) {
                $.ajax({
                    url: 'XXX3',
                    success: function(res) {
                        // todo
                    },
                    fail: function(err) {
                        console.log(err)
                    }
                })
            },
            fail: function(err) {
                console.log(err)
            }
        }) 
    },
    fail: function(err) {
    	console.log(err)
	}
})
```

在上例中，我们看到这段回调函数，不断的在回调，这只是三层回调，在实际应用中，我们遇到的需求会更复杂，回调也许更多，调试起来也就更麻烦，代码也更不美观，这就是我们要引入的第一个问题：回调地狱。

**问题1: 回调地狱**

回调地狱是JS里一个约定俗成的名称，一般情况下，一个业务依赖于上层业务，上层业务又依赖于更上一层的业务，以此类推，如果我们使用回调函数来处理异步的话，就会出现回调地狱。

主要是因为：大脑对业务的逻辑处理是线性的、阻塞的、单线程的，但是回调表达异步的方式是非线形的、非顺序的，这使得正确推导这类代码的难度很大，很容易出bug。

再例如：

```
// A
$.ajax({
    ...
    success: function (...) {
        // C
    }
});
// B
```

A和B发生于现在，在JavaScript主程序的直接控制之下，而C会延迟到将来发生，并且是在第三方的控制下，在本例中就是函数$.ajax(...)。从根本上来说，这种控制的转移通常不会给程序带来很多问题。

但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调驱动设计最严重（也是最微妙）的问题。它以这样一个思路为中心：有时候ajax(...)，也就是你交付回调函数的第三方不是你编写的代码，也不在你的直接控制之下，它是某个第三方提供的工具。

这种情况称为**控制反转**，也就是把自己程序一部分的执行控制交给某个第三方，在你的代码和第三方工具直接有一份并没有明确表达的契约。

既然是无法控制的第三方在执行你的回调函数，那么就有可能存在以下问题，当然通常情况下是不会发生的：

1. 调用回调过早
2. 调用回调过晚
3. 调用回调次数太多或者太少
4. 未能把所需的参数成功传给你的回调函数
5. 吞掉可能出现的错误或异常
6. ......

这种控制反转会导致信任链的完全断裂，如果你没有采取行动来解决这些控制反转导致的信任问题，那么你的代码已经有了隐藏的Bug，尽管我们大多数人都没有这样做。

这里，我们引出了回调函数处理异步的第二个问题：控制反转。

**问题2：控制反转**

综上，回调函数处理异步流程存在2个问题：

**1. 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符**

**2. 缺乏可信任性： 控制反转导致的一系列信任问题**

那么如何来解决这两个问题，先驱者们开始了探索之路......



