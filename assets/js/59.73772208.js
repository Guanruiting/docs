(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{234:function(a,t,s){"use strict";s.r(t);var e=s(0),p=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"_2-1-3-生命周期与数据操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-3-生命周期与数据操作"}},[a._v("#")]),a._v(" 2.1.3 生命周期与数据操作")]),a._v(" "),s("h2",{attrs:{id:"生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[a._v("#")]),a._v(" 生命周期")]),a._v(" "),s("p",[a._v('<p>React生命周期三个阶段：创建期、存在期、销毁期。</p><p><img alt="image.png" title="image.png" src="https://cdn.nlark.com/yuque/0/2019/png/325426/1565485074617-a08d222a-756a-4c92-a664-6d771367419f.png#align=left&display=inline&height=418&name=image.png&originHeight=586&originWidth=681&size=76720&status=done&width=486" style="max-width: 600px; width: 486px;"></p><p><img alt="image.png" title="image.png" src="https://cdn.nlark.com/yuque/0/2019/png/325426/1565485296904-724cae19-38aa-4202-bda1-a329f98e5a07.png#align=left&display=inline&height=447&name=image.png&originHeight=638&originWidth=709&size=118231&status=done&width=497" style="max-width: 600px; width: 497px;"></p><p><img alt="image.png" title="image.png" src="https://cdn.nlark.com/yuque/0/2019/png/325426/1565485377734-71236eb9-8115-4009-8961-71fbeb694acc.png#align=left&display=inline&height=173&name=image.png&originHeight=237&originWidth=683&size=36754&status=done&width=500" style="max-width: 600px; width: 500px;"></p>')]),a._v(" "),s("h2",{attrs:{id:"数据操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据操作"}},[a._v("#")]),a._v(" 数据操作")]),a._v(" "),s("p",[a._v('<p><span style="background-color: #FADB14;">state与props相同之处：</span></p><p>改变会触发render函数（UI的改变）</p><p><span style="background-color: #FADB14;">state与props不同之处：</span></p><p>1、state（writeable,readable）， props（readable）</p><p>2、state（组件内部数据），props （来自父组件）</p>')]),a._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 父组件")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("son name"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"{this.state.name}/"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 子组件")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("props"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" \n")])])]),s("p",[a._v("</son><p>组件嵌套层级比较深的时候用“上下文”传递数据。</p>")]),a._v(" "),s("h2",{attrs:{id:"课后思考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#课后思考"}},[a._v("#")]),a._v(" 课后思考")]),a._v(" "),s("h3",{attrs:{id:"如何理解-react-组件的生命周期？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何理解-react-组件的生命周期？"}},[a._v("#")]),a._v(" 如何理解 React 组件的生命周期？")]),a._v(" "),s("p",[a._v("<p>React 组件的生命周期函数（钩子函数），能响应不同的状态。</p><p>组件的生命周期可分成三个状态：</p><ul><li>Mounting：已插入真实 DOM</li><li>Updating：正在被重新渲染</li><li>Unmounting：已移出真实 DOM</li></ul>")]),a._v(" "),s("h3",{attrs:{id:"什么是props"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是props"}},[a._v("#")]),a._v(" 什么是Props?")]),a._v(" "),s("p",[a._v('<p>Props属性用于组件传值。</p><p><span class="lake-fontsize-12" style="color: #545454;">每个组件都可以接受一个 </span><code>props</code><span class="lake-fontsize-12" style="color: #545454;"> </span><span class="lake-fontsize-12" style="color: #545454;"><span>参</span></span><span class="lake-fontsize-12" style="color: #545454;">数，它是一个对象，包含了所有你对这个组件的配置。</span></p><p>在使用一个组件的时候，可以把参数放在标签的属性当中，所有的属性都会作为 <code>props</code> 对象的键值。</p><p><span class="lake-fontsize-12" style="color: #545454;">就像你在用普通的 HTML 标签的属性一样，可以把参数放在表示组件的标签上，</span><span class="lake-fontsize-12" style="color: #545454;">组件内部就可以通过 </span><code>this.props</code><span class="lake-fontsize-12" style="color: #545454;"> 来访问到这些配置参数了。</span></p>')]),a._v(" "),s("h3",{attrs:{id:"react中的状态是什么？它是如何使用的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react中的状态是什么？它是如何使用的？"}},[a._v("#")]),a._v(" React中的状态是什么？它是如何使用的？")]),a._v(" "),s("p",[a._v("<p>React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。</p><p>React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面。因此，State是一个组件的UI数据模型，是组件渲染时的数据依据。</p><p>State是可变的，是组件内部维护的一组用于反映组件UI变化的状态集合；而Props对于使用它的组件来说，是只读的，要想修改Props，只能通过该组件的父组件修改。在组件状态上移的场景中，父组件正是通过子组件的Props, 传递给子组件其所需要的状态。</p>")]),a._v(" "),s("h3",{attrs:{id:"调用setstate之后发生了什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调用setstate之后发生了什么？"}},[a._v("#")]),a._v(" 调用setState之后发生了什么？")]),a._v(" "),s("h3",{attrs:{id:"父子组件嵌套后的生命周期是怎样的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#父子组件嵌套后的生命周期是怎样的？"}},[a._v("#")]),a._v(" 父子组件嵌套后的生命周期是怎样的？")])])}),[],!1,null,null,null);t.default=p.exports}}]);